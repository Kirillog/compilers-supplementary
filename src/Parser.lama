-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop(l, op, r) {
  Binop(op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    binaryExpression = memo $ eta expr({
        [Left, {[s ("!!"), binop]}],
        [Left, {[s ("&&"), binop]}],
        [Nona, {
          [s ("=="), binop],
          [s ("!="), binop],
          [s ("<="), binop],
          [s (">="), binop],
          [s ("<"), binop],
          [s (">"), binop]
        }],
        [Left, {
          [s ("+"), binop],
          [s ("-"), binop]
        }],
        [Left, {
          [s ("*"), binop],
          [s ("/"), binop],
          [s ("%"), binop]
        }]
      }, primary),
    exp = memo $ eta binaryExpression,
    stmt = memo $ eta syntax (
      kRead x=inbr[s("("), lident, s(")")]  { Read (x) }    |
      kWrite e=inbr[s("("), exp, s(")")]    { Write (e) }   |
      kSkip                                 { Skip }        |
      x=lident s[":="] v=exp                { Assn (x, v) }),
    stmtList = memo $ eta syntax (
      stmt |
      head=stmt s[";"] tail=stmtList {Seq (head, tail)});

-- Public top-level parser
public parse = stmtList;

